# Default values for filesender.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: ghcr.io/mecmus/filesender
  tag: "3.5-php8.5"
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Configuration FileSender
filesender:
  siteUrl: "https://filesender.example.com"
  siteHostname: ""  # Extracted from siteUrl if empty
  siteName: "FileSender"
  admin: "testadmin"
  adminEmail: "admin@example.com"
  emailReplyTo: "noreply@example.com"
  defaultTimezone: "Europe/Paris"
  
  # Configuration email via Microsoft Graph API
  # Permet d'envoyer les emails de notification via une shared mailbox Exchange Online
  # Utilise la même application Entra ID que pour le SAML SSO
  # Voir ENTRA_ID_SETUP.md pour la configuration complète
  mail:
    enabled: false
    # Adresse d'envoi (shared mailbox Exchange Online, pas de licence requise)
    fromAddress: "noreply-filesender@example.com"
    # Client secret de l'application Entra ID (la même que pour le SAML)
    # Le tenantId et applicationId sont récupérés depuis simplesamlphp.saml.entra.*
    clientSecret: ""
    # Ou référencer un secret Kubernetes existant
    existingSecret: ""
    existingSecretKey: "graph-client-secret"
    # Activer le mode "envoyé au nom de" (sent on behalf of)
    # Quand activé, les destinataires voient "shared-mailbox au nom de Utilisateur"
    # Requiert la permission Exchange Online "Send on Behalf" sur la shared mailbox
    sendOnBehalfOf: false
  
  # Session configuration
  sessionCookiePath: "/"
  auth:
    forceSessionStartFirst: true
  
  # Stockage des fichiers
  storage:
    type: "filesystem"  # "filesystem" or "CloudS3"
    path: "/opt/filesender/filesender/files"
    shredPath: "/opt/filesender/filesender/shredfiles"
    usageWarning: 20
    # S3 Cloud Storage configuration (used when type is "CloudS3")
    s3:
      endpoint: ""
      region: "us-east-1"
      version: "latest"
      usePathStyleEndpoint: true
      bucket: ""
      useDailyBucket: false
      bucketPrefix: ""
      bulkDelete: false
      bulkSize: 1000
      # Credentials: use key/secret directly or reference an existing Secret
      key: ""
      secret: ""
      existingSecret: ""
      existingSecretKeyAccessKey: "s3-access-key"
      existingSecretKeySecretKey: "s3-secret-key"
  uploadChunkSize: ""
  
  # Chemins de fichiers
  paths:
    tmp: "/opt/filesender/filesender/tmp"
    log: "/opt/filesender/filesender/log"
  
  # Limites
  maxTransferSize: "107374182400"  # 100GB
  maxTransferFiles: 100
  defaultTransferDaysValid: 20
  maxTransferDaysValid: 60
  
  # TeraSender (upload haute vitesse)
  terasender:
    enabled: true
    advanced: false
    workerCount: 6
    startMode: "multiple"
  
  # Encryption
  encryption:
    enabled: true
    mandatory: true  # Files encrypted by default as requested
    minPasswordLength: 12
    mustHaveUpperAndLowerCase: true
    mustHaveNumbers: true
    mustHaveSpecialCharacters: true
  
  # Guest/Invités
  guest:
    enabled: true
    defaultDaysValid: 20
    maxDaysValid: 20
    minDaysValid: 1
    maxRecipients: 50
    limitPerUser: 50
  
  # Sécurité
  security:
    forceSSL: true
    useStrictCSP: true
    banExtension: "exe,bat"

# Pod Security Context
podSecurityContext:
  fsGroup: 82 # www-data on Alpine, ensures write permissions on mounted volumes

# Container Security Context
containerSecurityContext:
  runAsUser: 0 # Running as root to allow supervisor to manage processes
  runAsGroup: 0
  allowPrivilegeEscalation: false

# Configuration SimpleSAMLphp
# Configuration SimpleSAMLphp
simplesamlphp:
  adminPassword: ""  # Sera généré si vide
  secretSalt: ""     # Sera généré si vide
  
  # Session configuration
  session:
    storeType: "sql"
    cookiePath: "/"
    cookieName: "SimpleSAMLSessionID"
    tablePrefix: "simplesaml_"
  
  # Pour tests avec utilisateurs locaux
  localUsers:
    enabled: true
    users:
      - username: "testuser"
        password: ""  # Sera généré si vide
        email: "test@example.com"
        uid: "testuser"
      - username: "testadmin"
        password: ""  # Sera généré si vide
        email: "testadmin@example.com"
        uid: "testadmin"

  # SAML Configuration
  saml:
    # Provider type: "entra" (Microsoft Entra ID) or "other" (Generic SAML)
    # If "entra": uses tenantId/applicationId to auto-configure metadata and attributes.
    # If "other": requires explicit metadataUrl (or xml) and attribute mapping.
    provider: "other"
    
    # Microsoft Entra ID Configuration
    entra:
      tenantId: "" # Required if provider is "entra"
      applicationId: "" # Required if provider is "entra". Used to construct metadata URL.
      metadataUrl: "" # Optional: Override auto-generated metadata URL. Default is https://login.microsoftonline.com/<tenantId>/federationmetadata/2007-06/federationmetadata.xml?appid=<applicationId>
      metadataXml: "" # Optional: Paste XML content here to avoid outbound connection
    
    # Generic/Other IDP Configuration
    other:
      metadataUrl: "" # URL to fetch metadata from
      metadataXml: "" # OR Paste XML content here
      
      # Attribute mapping (Local FileSender attribute -> SAML Attribute Name)
      attributes:
        uid: "eduPersonTargetedID"
        email: "mail"
        name: "cn"


# Configuration PostgreSQL
postgresql:
  # Utiliser une base externe
  external:
    enabled: false
    host: ""
    port: 5432
    database: "filesender"
    username: "filesender"
    password: ""
    existingSecret: ""
    secretKey: "password"
  
  # Déployer PostgreSQL dans le cluster
  internal:
    enabled: true
    image:
      repository: postgres
      tag: "16-alpine"
      pullPolicy: IfNotPresent
    database: "filesender"
    username: "filesender"
    password: ""  # Sera généré si vide
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
      accessMode: ReadWriteOnce

# Persistence pour les fichiers uploadés
persistence:
  enabled: true
  size: 100Gi
  storageClass: ""
  accessMode: ReadWriteOnce

# Configuration Nginx (intégré dans l'image)
nginx:
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "200m"

# Service
service:
  type: ClusterIP
  port: 80

# Ingress
ingress:
  enabled: true
  className: ""
  annotations: {}
    # For nginx-ingress controller, these annotations help with HTTPS:
    # nginx.ingress.kubernetes.io/ssl-redirect: "true"
    # nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    # For cert-manager with Let's Encrypt:
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: filesender.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: filesender-tls
  #    hosts:
  #      - filesender.example.com

# Resources pour le conteneur FileSender
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# CronJob pour le nettoyage
cleanup:
  enabled: true
  schedule: "0 2 * * *"

# Probes
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 80
    scheme: HTTP
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 3
  
readinessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 80
    scheme: HTTP
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3

nodeSelector: {}
tolerations: []
affinity: {}
