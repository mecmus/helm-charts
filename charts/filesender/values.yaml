replicaCount: 1

image:
  repository: ghcr.io/mecmus/filesender
  tag: "3.3-oidc"  # Nouvelle image sans SimpleSAMLphp
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  automount: true
  annotations: {}
  name: ""

podAnnotations: {}
podLabels: {}
podSecurityContext: {}
securityContext: {}

filesender:
  siteUrl: "https://filesender.example.com"
  siteName: "FileSender"
  admin: "admin@example.com"
  adminEmail: "admin@example.com"
  emailReplyTo: "noreply@example.com"
  defaultTimezone: "Europe/Paris"
  
  # Storage
  storage:
    type: "filesystem"
    path: "/opt/filesender/filesender/files"
  
  paths:
    tmp: "/opt/filesender/filesender/tmp"
    log: "/opt/filesender/filesender/log"
  
  # Transfer limits
  maxTransferSize: "107374182400"
  maxTransferFiles: 100
  defaultTransferDaysValid: 20
  maxTransferDaysValid: 60

  # Authentication - SIMPLIFIED
  auth:
    # Type: "oidc" (production with Entra ID) or "fake" (dev/test)
    type: "oidc"
    
    # Fake mode - Zero dependencies, for dev/test only
    fake:
      enabled: false
      uid: "testuser"
      email: "test@example.com"
      name: "Test User"
    
    # OIDC mode - For Microsoft Entra ID (Azure AD)
    oidc:
      # Microsoft Entra ID issuer URL
      # Format: https://login.microsoftonline.com/<TENANT_ID>/v2.0
      issuer: ""
      
      # Client credentials (from Azure App Registration)
      clientId: ""
      clientSecret: ""
      
      # Or use existing secret with keys: oidc-client-id, oidc-client-secret
      existingSecret: ""
      
      # Attribute mapping
      uidAttribute: "sub"      # or "oid" for Azure Object ID
      emailAttribute: "email"
      nameAttribute: "name"
      
      # Scopes to request
      scopes:
        - "openid"
        - "profile"
        - "email"
      
      # Optional: Restrict to specific groups
      requiredGroups: []
      groupsClaim: "groups"

# PostgreSQL configuration
postgresql:
  external:
    enabled: false
    host: ""
    port: 5432
    database: "filesender"
    username: "filesender"
    password: ""
    existingSecret: ""
    secretKey: "password"
  
  internal:
    enabled: true
    image:
      repository: postgres
      tag: "15-alpine"
    database: "filesender"
    username: "filesender"
    password: ""
    persistence:
      enabled: true
      size: 10Gi

# Persistence for uploaded files
persistence:
  enabled: true
  size: 100Gi
  storageClass: ""
  accessMode: ReadWriteOnce

# This section builds out the service account more information can be found here: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created.
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account.
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template.
  name: ""

# This is for setting Kubernetes Annotations to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/
podAnnotations: {}
# This is for setting Kubernetes Labels to a Pod.
# For more information checkout: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
podLabels: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# Service
service:
  type: ClusterIP
  port: 80

# Ingress
ingress:
  enabled: true
  className: ""
  annotations: {}
  hosts:
    - host: filesender.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []

# HTTPRoute (Gateway API)
httpRoute:
  enabled: false
  annotations: {}
  parentRefs:
    - name: gateway
      sectionName: http
  hostnames:
    - filesender.example.com
  rules:
    - matches:
        - path:
            type: PathPrefix
            value: /

# Resources
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# Probes
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 80
  initialDelaySeconds: 30
  periodSeconds: 10

readinessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 80
  initialDelaySeconds: 10
  periodSeconds: 5

# Cleanup cronjob
cleanup:
  enabled: true
  schedule: "0 2 * * *"

# Autoscaling
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80

nodeSelector: {}
tolerations: []
affinity: {}

