# Default values for filesender.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: ghcr.io/mecmus/filesender
  tag: "3.3"
  pullPolicy: IfNotPresent

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Configuration FileSender
filesender:
  siteUrl: "https://filesender.example.com"
  siteName: "FileSender"
  admin: "testadmin"
  adminEmail: "admin@example.com"
  emailReplyTo: "noreply@example.com"
  defaultTimezone: "Europe/Paris"
  
  # Session configuration
  sessionCookiePath: "/"
  auth:
    forceSessionStartFirst: true
  
  # Stockage des fichiers
  storage:
    type: "filesystem"
    path: "/opt/filesender/filesender/files"
    shredPath: "/opt/filesender/filesender/shredfiles"
    usageWarning: 20
  
  # Chemins de fichiers
  paths:
    tmp: "/opt/filesender/filesender/tmp"
    log: "/opt/filesender/filesender/log"
  
  # Limites
  maxTransferSize: "107374182400"  # 100GB
  maxTransferFiles: 100
  defaultTransferDaysValid: 20
  maxTransferDaysValid: 60
  
  # TeraSender (upload haute vitesse)
  terasender:
    enabled: true
    advanced: false
    workerCount: 6
    startMode: "multiple"
  
  # Encryption
  encryption:
    enabled: true
    mandatory: false
    minPasswordLength: 12
    mustHaveUpperAndLowerCase: true
    mustHaveNumbers: true
    mustHaveSpecialCharacters: true
  
  # Guest/Invités
  guest:
    enabled: true
    defaultDaysValid: 20
    maxDaysValid: 20
    minDaysValid: 1
    maxRecipients: 50
    limitPerUser: 50
  
  # Sécurité
  security:
    forceSSL: true
    useStrictCSP: true
    banExtension: "exe,bat"

# Configuration SimpleSAMLphp
simplesamlphp:
  adminPassword: ""  # Sera généré si vide
  secretSalt: ""     # Sera généré si vide
  authType: "fake"   # saml, shibboleth, fake
  authenticationSource: "default-sp"
  uidAttribute: "eduPersonTargetedID"
  emailAttribute: "mail"
  nameAttribute: "cn"
  
  # Session configuration
  session:
    storeType: "sql"
    cookiePath: "/"
    cookieName: "SimpleSAMLSessionID"
    tablePrefix: "simplesaml_"
  
  # Pour tests avec utilisateurs locaux
  localUsers:
    enabled: true
    users:
      - username: "testuser"
        password: ""  # Sera généré si vide
        email: "test@example.com"
        uid: "testuser"
      - username: "testadmin"
        password: ""  # Sera généré si vide
        email: "testadmin@example.com"
        uid: "testadmin"
  
  # Configuration IdP externe (ex: Microsoft Entra ID, ADFS, etc.)
  # Pour activer, mettre localUsers.enabled à false
  idp:
    # Entity ID de l'IdP (ex: https://sts.windows.net/<tenant-id>/ pour Entra ID)
    entityId: ""
    # URL du service SSO (ex: https://login.microsoftonline.com/<tenant-id>/saml2)
    ssoUrl: ""
    # Certificat de signature SAML de l'IdP (format PEM, une seule ligne)
    certificate: ""
    # URL des métadonnées de l'IdP (optionnel, alternative au certificat)
    metadataUrl: ""
  
  # Configuration spécifique pour Microsoft Entra ID
  entraId:
    # Activer l'intégration Entra ID (désactive localUsers automatiquement)
    enabled: false
    # Tenant ID Azure (GUID)
    tenantId: ""
    # Application (client) ID
    clientId: ""
    # Attributs mappés depuis Entra ID
    attributes:
      # Nom de l'attribut pour l'email dans les claims Entra ID
      email: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress"
      # Nom de l'attribut pour le nom d'utilisateur
      name: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name"
      # Nom de l'attribut pour l'identifiant unique
      uid: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier"

# Configuration PostgreSQL
postgresql:
  # Utiliser une base externe
  external:
    enabled: false
    host: ""
    port: 5432
    database: "filesender"
    username: "filesender"
    password: ""
    existingSecret: ""
    secretKey: "password"
  
  # Déployer PostgreSQL dans le cluster
  internal:
    enabled: true
    image:
      repository: postgres
      tag: "15-alpine"
      pullPolicy: IfNotPresent
    database: "filesender"
    username: "filesender"
    password: ""  # Sera généré si vide
    resources:
      requests:
        memory: "256Mi"
        cpu: "100m"
      limits:
        memory: "512Mi"
        cpu: "500m"
    persistence:
      enabled: true
      size: 10Gi
      storageClass: ""
      accessMode: ReadWriteOnce

# Persistence pour les fichiers uploadés
persistence:
  enabled: true
  size: 100Gi
  storageClass: ""
  accessMode: ReadWriteOnce

# Configuration Nginx (intégré dans l'image)
nginx:
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "200m"

# Service
service:
  type: ClusterIP
  port: 80

# Ingress
ingress:
  enabled: true
  className: ""
  annotations: {}
    # For nginx-ingress controller, these annotations help with HTTPS:
    # nginx.ingress.kubernetes.io/ssl-redirect: "true"
    # nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    # For cert-manager with Let's Encrypt:
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
  hosts:
    - host: filesender.example.com
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: filesender-tls
  #    hosts:
  #      - filesender.example.com

# Resources pour le conteneur FileSender
resources:
  requests:
    memory: "256Mi"
    cpu: "100m"
  limits:
    memory: "512Mi"
    cpu: "500m"

# CronJob pour le nettoyage
cleanup:
  enabled: true
  schedule: "0 2 * * *"

# Probes
livenessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 80
    scheme: HTTP
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 3
  
readinessProbe:
  enabled: true
  httpGet:
    path: /health
    port: 80
    scheme: HTTP
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3

nodeSelector: {}
tolerations: []
affinity: {}
